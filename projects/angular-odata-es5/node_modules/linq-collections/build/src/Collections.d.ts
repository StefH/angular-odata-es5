import { Action, Aggregator, Dynamic, Indexer, Predicate, Selector, ZipSelector, Type } from "./Types";
import { IEnumerable, IGrouping, IKeyValue, IOrderedEnumerable, IQueryable } from "./Enumerables";
import { Comparer, EqualityComparer } from "./Comparers";
export declare abstract class EnumerableCollection<TElement> implements IQueryable<TElement> {
    abstract copy(): IQueryable<TElement>;
    abstract asEnumerable(): IEnumerable<TElement>;
    abstract toArray(): TElement[];
    toList(): IList<TElement>;
    toDictionary<TKey extends Indexer, TValue>(keySelector: Selector<TElement, TKey>, valueSelector: Selector<TElement, TValue>): IDictionary<TKey, TValue>;
    reverse(): IEnumerable<TElement>;
    concat(other: TElement[] | IQueryable<TElement>, ...others: Array<TElement[] | IQueryable<TElement>>): IEnumerable<TElement>;
    contains(element: TElement): boolean;
    where(predicate: Predicate<TElement>): IEnumerable<TElement>;
    select<TSelectorOut>(selector: Selector<TElement, TSelectorOut>): IEnumerable<TSelectorOut>;
    selectMany<TSelectorOut>(selector: Selector<TElement, TSelectorOut[] | List<TSelectorOut> | IEnumerable<TSelectorOut>>): IEnumerable<TSelectorOut>;
    elementAt(index: number): TElement;
    except(other: IQueryable<TElement>): IEnumerable<TElement>;
    first(): TElement;
    first(predicate: Predicate<TElement>): TElement;
    groupBy<TKey extends Indexer>(keySelector: Selector<TElement, TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    groupBy<TKey extends Indexer, TValue>(keySelector: Selector<TElement, TKey>, valueSelector: Selector<TElement, TValue>): IEnumerable<IGrouping<TKey, TValue>>;
    last(): TElement;
    last(predicate: Predicate<TElement>): TElement;
    single(): TElement;
    single(predicate: Predicate<TElement>): TElement;
    singleOrDefault(): TElement | undefined;
    singleOrDefault(predicate: Predicate<TElement>): TElement | undefined;
    skipWhile(predicate: Predicate<TElement>): IEnumerable<TElement>;
    takeWhile(predicate: Predicate<TElement>): IEnumerable<TElement>;
    sequenceEqual(other: IQueryable<TElement> | TElement[]): boolean;
    sequenceEqual(other: IQueryable<TElement> | TElement[], comparer: EqualityComparer<TElement>): boolean;
    distinct(): IEnumerable<TElement>;
    distinct<TKey>(keySelector: Selector<TElement, TKey>): IEnumerable<TElement>;
    min(): TElement;
    min<TSelectorOut>(selector: Selector<TElement, TSelectorOut>): TSelectorOut;
    orderBy<TKey>(keySelector: Selector<TElement, TKey>): IOrderedEnumerable<TElement>;
    orderBy<TKey>(keySelector: Selector<TElement, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TElement>;
    orderByDescending<TKey>(keySelector: Selector<TElement, TKey>): IOrderedEnumerable<TElement>;
    max(): TElement;
    max<TSelectorOut>(selector: Selector<TElement, TSelectorOut>): TSelectorOut;
    sum(selector: Selector<TElement, number>): number;
    skip(amount: number): IEnumerable<TElement>;
    take(amount: number): IEnumerable<TElement>;
    union(other: IQueryable<TElement>): IEnumerable<TElement>;
    aggregate(aggregator: Aggregator<TElement, TElement | undefined>): TElement;
    aggregate<TValue>(aggregator: Aggregator<TElement, TValue>, initialValue: TValue): TValue;
    any(): boolean;
    any(predicate: Predicate<TElement>): boolean;
    all(predicate: Predicate<TElement>): boolean;
    average(selector: Selector<TElement, number>): number;
    count(): number;
    count(predicate: Predicate<TElement>): number;
    elementAtOrDefault(index: number): TElement | undefined;
    firstOrDefault(): TElement | undefined;
    firstOrDefault(predicate: Predicate<TElement>): TElement | undefined;
    lastOrDefault(): TElement | undefined;
    lastOrDefault(predicate: Predicate<TElement>): TElement | undefined;
    forEach(action: Action<TElement>): void;
    defaultIfEmpty(): IEnumerable<TElement | undefined>;
    defaultIfEmpty(defaultValue: TElement): IEnumerable<TElement>;
    zip<TOther, TSelectorOut>(other: IQueryable<TOther> | TOther[], selector: ZipSelector<TElement, TOther, TSelectorOut>): IEnumerable<TSelectorOut>;
}
export declare abstract class ArrayQueryable<TElement> extends EnumerableCollection<TElement> {
    protected source: TElement[];
    abstract copy(): IQueryable<TElement>;
    constructor();
    constructor(elements: TElement[]);
    asArray(): TElement[];
    toArray(): TElement[];
    toList(): IList<TElement>;
    asEnumerable(): IEnumerable<TElement>;
    aggregate(aggregator: Aggregator<TElement, TElement | undefined>): TElement;
    aggregate<TValue>(aggregator: Aggregator<TElement, TValue>, initialValue: TValue): TValue;
    any(): boolean;
    any(predicate: Predicate<TElement>): boolean;
    all(predicate: Predicate<TElement>): boolean;
    average(selector: Selector<TElement, number>): number;
    count(): number;
    count(predicate: Predicate<TElement>): number;
    elementAtOrDefault(index: number): TElement | undefined;
    firstOrDefault(): TElement | undefined;
    firstOrDefault(predicate: Predicate<TElement>): TElement | undefined;
    groupBy<TKey extends Indexer>(keySelector: Selector<TElement, TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    groupBy<TKey extends Indexer, TValue>(keySelector: Selector<TElement, TKey>, valueSelector: Selector<TElement, TValue>): IEnumerable<IGrouping<TKey, TValue>>;
    lastOrDefault(): TElement | undefined;
    lastOrDefault(predicate: Predicate<TElement>): TElement | undefined;
    forEach(action: Action<TElement>): void;
    sequenceEqual(other: IQueryable<TElement> | TElement[]): boolean;
    sequenceEqual(other: IQueryable<TElement> | TElement[], comparer: EqualityComparer<TElement>): boolean;
}
export interface IReadOnlyList<TElement> extends IQueryable<TElement> {
    copy(): IList<TElement>;
    get(index: number): TElement | undefined;
    indexOf(element: TElement): number;
}
export interface IList<TElement> extends IReadOnlyList<TElement> {
    asReadOnly(): IReadOnlyList<TElement>;
    asArray(): TElement[];
    clear(): void;
    push(element: TElement): number;
    pushRange(elements: TElement[] | IQueryable<TElement>): number;
    pushFront(element: TElement): number;
    pop(): TElement | undefined;
    popFront(): TElement | undefined;
    remove(element: TElement): void;
    removeAt(index: number): TElement | undefined;
    set(index: number, element: TElement): void;
    insert(index: number, element: TElement): void;
}
export declare class List<TElement> extends ArrayQueryable<TElement> implements IList<TElement> {
    copy(): IList<TElement>;
    asReadOnly(): IReadOnlyList<TElement>;
    clear(): void;
    remove(element: TElement): void;
    removeAt(index: number): TElement | undefined;
    get(index: number): TElement | undefined;
    push(element: TElement): number;
    pushRange(elements: TElement[] | IQueryable<TElement>): number;
    pushFront(element: TElement): number;
    pop(): TElement | undefined;
    popFront(): TElement | undefined;
    set(index: number, element: TElement): void;
    insert(index: number, element: TElement): void;
    indexOf(element: TElement): number;
}
export interface IStack<TElement> extends IQueryable<TElement> {
    copy(): IStack<TElement>;
    asArray(): TElement[];
    clear(): void;
    peek(): TElement | undefined;
    pop(): TElement | undefined;
    push(element: TElement): number;
}
export declare class Stack<TElement> extends ArrayQueryable<TElement> implements IStack<TElement> {
    copy(): IStack<TElement>;
    clear(): void;
    peek(): TElement | undefined;
    pop(): TElement | undefined;
    push(element: TElement): number;
}
export interface IReadOnlyDictionary<TKey extends Indexer, TValue> extends IQueryable<IKeyValue<TKey, TValue>> {
    copy(): IDictionary<TKey, TValue>;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getKeys(): IList<TKey>;
    getValues(): IList<TValue>;
    get(key: TKey): TValue;
}
export interface IDictionary<TKey extends Indexer, TValue> extends IReadOnlyDictionary<TKey, TValue> {
    asReadOnly(): IReadOnlyDictionary<TKey, TValue>;
    clear(): void;
    remove(key: TKey): void;
    set(key: TKey, value: TValue): void;
    setOrUpdate(key: TKey, value: TValue): void;
}
export declare class Dictionary<TKey extends Indexer, TValue> extends EnumerableCollection<IKeyValue<TKey, TValue>> implements IDictionary<TKey, TValue> {
    static fromArray<TArray, TKey extends Indexer, TValue>(array: TArray[], keySelector: Selector<TArray, TKey>, valueSelector: Selector<TArray, TValue>): IDictionary<TKey, TValue>;
    static fromJsObject<TValue = string>(object: Dynamic): IDictionary<string, TValue>;
    protected dictionary: Dynamic;
    protected keyType: Type;
    constructor();
    constructor(keyValuePairs: Array<IKeyValue<TKey, TValue>>);
    copy(): IDictionary<TKey, TValue>;
    asReadOnly(): IReadOnlyDictionary<TKey, TValue>;
    asEnumerable(): IEnumerable<IKeyValue<TKey, TValue>>;
    toArray(): Array<IKeyValue<TKey, TValue>>;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getKeys(): IList<TKey>;
    protected getKeysFast(): string[];
    getValues(): IList<TValue>;
    remove(key: TKey): void;
    get(key: TKey): TValue;
    set(key: TKey, value: TValue): void;
    setOrUpdate(key: TKey, value: TValue): void;
}
