import { Action, Aggregator, Indexer, Predicate, Selector, ZipSelector } from "./Types";
import { IIterable } from "./Iterators";
import { Comparer, EqualityComparer } from "./Comparers";
import { IDictionary, IList, List } from "./Collections";
import { Cached } from "./Utils";
export interface IKeyValue<TKey, TValue> {
    key: TKey;
    value: TValue;
}
export declare type IGrouping<TKey, TElement> = IKeyValue<TKey, IQueryable<TElement>>;
export interface IQueryable<TOut> {
    copy(): IQueryable<TOut>;
    asEnumerable(): IEnumerable<TOut>;
    toArray(): TOut[];
    toList(): IList<TOut>;
    toDictionary<TKey extends Indexer, TValue>(keySelector: Selector<TOut, TKey>, valueSelector: Selector<TOut, TValue>): IDictionary<TKey, TValue>;
    aggregate(aggregator: Aggregator<TOut, TOut | undefined>): TOut;
    aggregate<TValue>(aggregator: Aggregator<TOut, TValue>, initialValue: TValue): TValue;
    all(predicate: Predicate<TOut>): boolean;
    any(): boolean;
    any(predicate: Predicate<TOut>): boolean;
    average(selector: Selector<TOut, number>): number;
    concat(other: TOut[] | IQueryable<TOut>, ...others: Array<TOut[] | IQueryable<TOut>>): IEnumerable<TOut>;
    contains(element: TOut): boolean;
    count(): number;
    count(predicate: Predicate<TOut>): number;
    defaultIfEmpty(): IEnumerable<TOut | undefined>;
    defaultIfEmpty(defaultValue: TOut): IEnumerable<TOut>;
    distinct(): IEnumerable<TOut>;
    distinct<TKey>(keySelector: Selector<TOut, TKey>): IEnumerable<TOut>;
    elementAt(index: number): TOut;
    elementAtOrDefault(index: number): TOut | undefined;
    except(other: IQueryable<TOut>): IEnumerable<TOut>;
    first(): TOut;
    first(predicate: Predicate<TOut>): TOut;
    firstOrDefault(): TOut | undefined;
    firstOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    forEach(action: Action<TOut>): void;
    groupBy<TKey extends Indexer>(keySelector: Selector<TOut, TKey>): IEnumerable<IGrouping<TKey, TOut>>;
    groupBy<TKey extends Indexer, TValue>(keySelector: Selector<TOut, TKey>, valueSelector: Selector<TOut, TValue>): IEnumerable<IGrouping<TKey, TValue>>;
    last(): TOut;
    last(predicate: Predicate<TOut>): TOut;
    lastOrDefault(): TOut | undefined;
    lastOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    max(): TOut;
    max<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): TSelectorOut;
    min(): TOut;
    min<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): TSelectorOut;
    orderBy<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
    orderBy<TKey>(keySelector: Selector<TOut, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TOut>;
    orderByDescending<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
    reverse(): IEnumerable<TOut>;
    select<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): IEnumerable<TSelectorOut>;
    selectMany<TSelectorOut>(selector: Selector<TOut, TSelectorOut[] | IQueryable<TSelectorOut>>): IEnumerable<TSelectorOut>;
    sequenceEqual(other: IQueryable<TOut> | TOut[]): boolean;
    sequenceEqual(other: IQueryable<TOut> | TOut[], comparer: EqualityComparer<TOut>): boolean;
    single(): TOut;
    single(predicate: Predicate<TOut>): TOut;
    singleOrDefault(): TOut | undefined;
    singleOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    skip(amount: number): IEnumerable<TOut>;
    skipWhile(predicate: Predicate<TOut>): IEnumerable<TOut>;
    sum(selector: Selector<TOut, number>): number;
    take(amount: number): IEnumerable<TOut>;
    takeWhile(predicate: Predicate<TOut>): IEnumerable<TOut>;
    union(other: IQueryable<TOut>): IEnumerable<TOut>;
    where(predicate: Predicate<TOut>): IEnumerable<TOut>;
    zip<TOther, TSelectorOut>(other: IQueryable<TOther> | TOther[], selector: ZipSelector<TOut, TOther, TSelectorOut>): IEnumerable<TSelectorOut>;
}
export interface IEnumerable<TOut> extends IQueryable<TOut>, IIterable<TOut> {
    copy(): IEnumerable<TOut>;
}
export interface IOrderedEnumerable<TOut> extends IEnumerable<TOut> {
    copy(): IOrderedEnumerable<TOut>;
    thenBy<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
    thenBy<TKey>(keySelector: Selector<TOut, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TOut>;
    thenByDescending<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
}
export declare abstract class EnumerableBase<TElement, TOut> implements IEnumerable<TOut> {
    protected readonly source: IIterable<TElement> | IEnumerable<TElement>;
    protected constructor(source: IIterable<TElement>);
    abstract copy(): IEnumerable<TOut>;
    abstract value(): TOut;
    reset(): void;
    next(): boolean;
    asEnumerable(): IEnumerable<TOut>;
    toArray(): TOut[];
    toList(): IList<TOut>;
    toDictionary<TKey extends Indexer, TValue>(keySelector: Selector<TOut, TKey>, valueSelector: Selector<TOut, TValue>): IDictionary<TKey, TValue>;
    count(): number;
    count(predicate: Predicate<TOut>): number;
    any(): boolean;
    any(predicate: Predicate<TOut>): boolean;
    all(predicate: Predicate<TOut>): boolean;
    reverse(): IEnumerable<TOut>;
    contains(element: TOut): boolean;
    sequenceEqual(other: IQueryable<TOut> | TOut[]): boolean;
    sequenceEqual(other: IQueryable<TOut> | TOut[], comparer: EqualityComparer<TOut>): boolean;
    where(predicate: Predicate<TOut>): IEnumerable<TOut>;
    select<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): IEnumerable<TSelectorOut>;
    selectMany<TSelectorOut>(selector: Selector<TOut, TSelectorOut[] | IQueryable<TSelectorOut>>): IEnumerable<TSelectorOut>;
    skipWhile(predicate: Selector<TOut, boolean>): IEnumerable<TOut>;
    concat(other: TOut[] | IQueryable<TOut>, ...others: Array<TOut[] | IQueryable<TOut>>): IEnumerable<TOut>;
    defaultIfEmpty(): IEnumerable<TOut | undefined>;
    defaultIfEmpty(defaultValue: TOut): IEnumerable<TOut>;
    elementAt(index: number): TOut;
    elementAtOrDefault(index: number): TOut | undefined;
    except(other: IQueryable<TOut>): IEnumerable<TOut>;
    first(): TOut;
    first(predicate: Predicate<TOut>): TOut;
    firstOrDefault(): TOut | undefined;
    firstOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    forEach(action: Action<TOut>): void;
    groupBy<TKey extends Indexer>(keySelector: Selector<TOut, TKey>): IEnumerable<IGrouping<TKey, TOut>>;
    groupBy<TKey extends Indexer, TValue>(keySelector: Selector<TOut, TKey>, valueSelector: Selector<TOut, TValue>): IEnumerable<IGrouping<TKey, TValue>>;
    last(): TOut;
    last(predicate: Predicate<TOut>): TOut;
    lastOrDefault(): TOut | undefined;
    lastOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    single(): TOut;
    single(predicate: Predicate<TOut>): TOut;
    singleOrDefault(): TOut | undefined;
    singleOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    distinct(): IEnumerable<TOut>;
    distinct<TKey>(keySelector: Selector<TOut, TKey>): IEnumerable<TOut>;
    aggregate(aggregator: Aggregator<TOut, TOut | undefined>): TOut;
    aggregate<TValue>(aggregator: Aggregator<TOut, TValue>, initialValue: TValue): TValue;
    min(): TOut;
    min<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): TSelectorOut;
    orderBy<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
    orderBy<TKey>(keySelector: Selector<TOut, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TOut>;
    orderByDescending<TKey>(keySelector: Selector<TOut, TKey>): IOrderedEnumerable<TOut>;
    max(): TOut;
    max<TSelectorOut>(selector: Selector<TOut, TSelectorOut>): TSelectorOut;
    sum(selector: Selector<TOut, number>): number;
    average(selector: Selector<TOut, number>): number;
    skip(amount: number): IEnumerable<TOut>;
    take(amount: number): IEnumerable<TOut>;
    takeWhile(predicate: Predicate<TOut>): IEnumerable<TOut>;
    union(other: IQueryable<TOut>): IEnumerable<TOut>;
    zip<TOther, TSelectorOut>(other: IQueryable<TOther> | TOther[], selector: ZipSelector<TOut, TOther, TSelectorOut>): IEnumerable<TSelectorOut>;
}
export declare class Enumerable<TElement> extends EnumerableBase<TElement, TElement> {
    protected currentValue: Cached<TElement>;
    static fromSource<TElement>(source: TElement[] | IIterable<TElement>): IEnumerable<TElement>;
    static empty<TElement>(): IEnumerable<TElement>;
    static range(start: number, count: number): IEnumerable<number>;
    static range(start: number, count: number, ascending: boolean): IEnumerable<number>;
    static repeat<TElement>(element: TElement, count: number): IEnumerable<TElement>;
    constructor(source: IIterable<TElement>);
    copy(): IEnumerable<TElement>;
    value(): TElement;
    reset(): void;
    next(): boolean;
}
export declare class ConditionalEnumerable<TElement> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _predicate;
    constructor(source: IEnumerable<TElement>, predicate: Predicate<TElement>);
    copy(): ConditionalEnumerable<TElement>;
    next(): boolean;
}
export declare class SkipWhileEnumerable<TElement> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _predicate;
    private _shouldContinueChecking;
    constructor(source: IEnumerable<TElement>, predicate: Predicate<TElement>);
    reset(): void;
    copy(): SkipWhileEnumerable<TElement>;
    next(): boolean;
}
export declare class TakeWhileEnumerable<TElement> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _predicate;
    private _shouldContinueTaking;
    constructor(source: IEnumerable<TElement>, predicate: Predicate<TElement>);
    reset(): void;
    copy(): TakeWhileEnumerable<TElement>;
    next(): boolean;
}
export declare class ConcatEnumerable<TElement> extends Enumerable<TElement> {
    private _otherSource;
    private _isFirstSourceFinished;
    constructor(left: IIterable<TElement>, right: IIterable<TElement>);
    copy(): ConcatEnumerable<TElement>;
    reset(): void;
    next(): boolean;
    value(): TElement;
}
export declare class UniqueEnumerable<TElement, TKey> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _seen;
    private _keySelector;
    constructor(source: IEnumerable<TElement>, keySelector?: Selector<TElement, TKey>);
    copy(): UniqueEnumerable<TElement, TKey>;
    reset(): void;
    private isUnique(element);
    next(): boolean;
}
export declare class RangeEnumerable<TElement> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _start;
    private _count;
    private _currentIndex;
    constructor(source: IEnumerable<TElement>, start: number | undefined, count: number | undefined);
    copy(): RangeEnumerable<TElement>;
    reset(): void;
    private isValidIndex();
    private performSkip();
    next(): boolean;
    value(): TElement;
}
export declare class TransformEnumerable<TElement, TOut> extends EnumerableBase<TElement, TOut> {
    protected source: IEnumerable<TElement>;
    private _transform;
    private _currentValue;
    constructor(source: IEnumerable<TElement>, transform: Selector<TElement, TOut>);
    copy(): TransformEnumerable<TElement, TOut>;
    value(): TOut;
    reset(): void;
    next(): boolean;
}
export declare class ReverseEnumerable<TElement> extends Enumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _elements;
    private _currentIndex;
    constructor(source: IEnumerable<TElement>);
    copy(): IEnumerable<TElement>;
    reset(): void;
    private isValidIndex();
    all(predicate: Predicate<TElement>): boolean;
    any(): boolean;
    any(predicate: Predicate<TElement>): boolean;
    average(selector: Selector<TElement, number>): number;
    count(): number;
    count(predicate: Predicate<TElement>): number;
    max(): TElement;
    max<TSelectorOut>(selector: Selector<TElement, TSelectorOut>): TSelectorOut;
    min(): TElement;
    min<TSelectorOut>(selector: Selector<TElement, TSelectorOut>): TSelectorOut;
    reverse(): IEnumerable<TElement>;
    sum(selector: Selector<TElement, number>): number;
    next(): boolean;
    value(): TElement;
}
export declare class OrderedEnumerable<TElement> extends EnumerableBase<TElement, TElement> implements IOrderedEnumerable<TElement> {
    protected source: IEnumerable<TElement>;
    private _comparer;
    private _elements;
    private _currentIndex;
    constructor(source: IEnumerable<TElement>, comparer: Comparer<TElement>);
    private isValidIndex();
    orderBy<TKey>(keySelector: Selector<TElement, TKey>): IOrderedEnumerable<TElement>;
    orderBy<TKey>(keySelector: Selector<TElement, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TElement>;
    orderByDescending<TKey>(keySelector: Selector<TElement, TKey>): IOrderedEnumerable<TElement>;
    thenBy<TKey>(keySelector: Selector<TElement, TKey>): IOrderedEnumerable<TElement>;
    thenBy<TKey>(keySelector: Selector<TElement, TKey>, comparer: Comparer<TKey>): IOrderedEnumerable<TElement>;
    thenByDescending<TKeySelector>(keySelector: Selector<TElement, TKeySelector>): IOrderedEnumerable<TElement>;
    reset(): void;
    copy(): IOrderedEnumerable<TElement>;
    value(): TElement;
    next(): boolean;
    toArray(): TElement[];
}
export declare class ArrayEnumerable<TOut> extends Enumerable<TOut> {
    protected list: List<TOut>;
    constructor(source: TOut[]);
    toArray(): TOut[];
    aggregate(aggregator: Aggregator<TOut, TOut | undefined>): TOut;
    aggregate<TValue>(aggregator: Aggregator<TOut, TValue>, initialValue: TValue): TValue;
    any(): boolean;
    any(predicate: Predicate<TOut>): boolean;
    all(predicate: Predicate<TOut>): boolean;
    average(selector: Selector<TOut, number>): number;
    count(): number;
    count(predicate: Predicate<TOut>): number;
    copy(): IEnumerable<TOut>;
    elementAtOrDefault(index: number): TOut | undefined;
    firstOrDefault(): TOut | undefined;
    firstOrDefault(predicate: Predicate<TOut>): TOut | undefined;
    lastOrDefault(): TOut | undefined;
    lastOrDefault(predicate: Predicate<TOut>): TOut | undefined;
}
export declare class DefaultIfEmptyEnumerable<TOut> extends EnumerableBase<TOut, TOut | undefined> {
    protected source: IEnumerable<TOut>;
    private _mustUseDefaultValue;
    private _defaultValue;
    constructor(source: IEnumerable<TOut>, defaultValue?: TOut);
    copy(): DefaultIfEmptyEnumerable<TOut>;
    value(): TOut | undefined;
    next(): boolean;
    reset(): void;
}
export declare class ZippedEnumerable<TElement, TOther, TOut> extends EnumerableBase<TElement, TOut> {
    private _otherSource;
    private _isOneOfTheSourcesFinished;
    private _currentValue;
    private _selector;
    constructor(source: IIterable<TElement>, otherSource: IIterable<TOther>, selector: ZipSelector<TElement, TOther, TOut>);
    copy(): ZippedEnumerable<TElement, TOther, TOut>;
    value(): TOut;
    reset(): void;
    next(): boolean;
}
